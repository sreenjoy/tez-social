name: Autonomous Monitoring

on:
  # Run every 15 minutes
  schedule:
    - cron: '*/15 * * * *'
  # Run on deployment events
  deployment_status:
  # Run on push to main branch
  push:
    branches:
      - main
    paths-ignore:
      - '.github/workflows/**'  # Avoid recursive triggers from bot fixes
      - '**.md'
  # Allow manual trigger
  workflow_dispatch:
  # Run when deployment monitor detects issues
  repository_dispatch:
    types: [deployment-issue-detected]

permissions:
  contents: write
  deployments: write
  actions: write
  checks: write
  pull-requests: write

jobs:
  monitor-and-fix:
    runs-on: ubuntu-latest
    # Add concurrency to prevent multiple runs from interfering
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: false  # Don't cancel in-progress runs to ensure monitoring completes
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better debugging

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm install -g @octokit/rest @octokit/auth-app

      - name: Wait for deployments to start
        if: github.event_name == 'push'
        run: |
          echo "New code pushed. Waiting 30 seconds for deployments to start..."
          sleep 30

      - name: Authenticate as bot
        id: auth
        env:
          APP_ID: ${{ secrets.AUTOBOT_APP_ID }}
          PRIVATE_KEY: ${{ secrets.AUTOBOT_PRIVATE_KEY }}
        run: |
          # Create authentication script
          cat > auth.js << 'EOL'
          const { createAppAuth } = require('@octokit/auth-app');
          const { Octokit } = require('@octokit/rest');
          
          async function getAuthToken() {
            try {
              const auth = createAppAuth({
                appId: process.env.APP_ID,
                privateKey: process.env.PRIVATE_KEY,
              });
              
              const installationAuth = await auth({ type: 'installation' });
              return installationAuth.token;
            } catch (error) {
              console.error('Authentication error:', error);
              process.exit(1);
            }
          }
          
          getAuthToken().then(token => {
            console.log(token);
          });
          EOL
          
          # Get authentication token
          TOKEN=$(node auth.js)
          echo "token=$TOKEN" >> $GITHUB_OUTPUT

      - name: Check deployment status
        id: check-deployment
        env:
          GITHUB_TOKEN: ${{ steps.auth.outputs.token }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          # Function to check deployment status
          check_deployment() {
            # Check Vercel deployment status
            DEPLOYMENT_STATUS=$(curl -s \
              -H "Authorization: Bearer $VERCEL_TOKEN" \
              "https://api.vercel.com/v6/deployments?teamId=$VERCEL_ORG_ID&projectId=$VERCEL_PROJECT_ID&limit=1" \
              | jq -r '.deployments[0].state')
            
            echo "Vercel deployment status: $DEPLOYMENT_STATUS"
            echo "deployment_status=$DEPLOYMENT_STATUS" >> $GITHUB_OUTPUT
            
            # Check Railway health
            RAILWAY_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" \
              https://tez-social-production.up.railway.app/api/health)
            
            echo "Railway health status: $RAILWAY_HEALTH"
            echo "railway_health=$RAILWAY_HEALTH" >> $GITHUB_OUTPUT
            
            # Return true if both are ready
            if [ "$DEPLOYMENT_STATUS" = "READY" ] && [ "$RAILWAY_HEALTH" = "200" ]; then
              return 0
            else
              return 1
            fi
          }
          
          # Initial check
          check_deployment
          
          # If triggered by push or deployment event, keep checking for up to 5 minutes
          if [ "${{ github.event_name }}" = "push" ] || [ "${{ github.event_name }}" = "deployment" ] || [ "${{ github.event_name }}" = "deployment_status" ]; then
            ATTEMPTS=0
            MAX_ATTEMPTS=30  # 5 minutes with 10-second intervals
            
            while ! check_deployment && [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
              echo "Deployment not ready. Waiting 10 seconds before next check..."
              sleep 10
              ATTEMPTS=$((ATTEMPTS + 1))
            done
            
            if [ $ATTEMPTS -eq $MAX_ATTEMPTS ]; then
              echo "Deployment did not complete successfully within 5 minutes."
              exit 1
            fi
          fi

      - name: Run diagnostic tests
        id: diagnostics
        if: steps.check-deployment.outputs.deployment_status != 'READY' || steps.check-deployment.outputs.railway_health != '200'
        run: |
          # Create diagnostics script
          cat > diagnose.js << 'EOL'
          const fs = require('fs');
          const path = require('path');
          
          function checkFrontendConfig() {
            const issues = [];
            
            // Check next.config.js
            try {
              const nextConfig = fs.readFileSync('frontend/next.config.js', 'utf8');
              if (!nextConfig.includes('NEXT_PUBLIC_BACKEND_URL')) {
                issues.push('Missing NEXT_PUBLIC_BACKEND_URL in next.config.js');
              }
            } catch (error) {
              issues.push('Could not read next.config.js');
            }
            
            // Check environment variables
            try {
              const envFile = fs.readFileSync('frontend/.env', 'utf8');
              if (!envFile.includes('NEXT_PUBLIC_BACKEND_URL')) {
                issues.push('Missing NEXT_PUBLIC_BACKEND_URL in .env');
              }
            } catch (error) {
              // .env file might not exist, which is okay
            }
            
            return issues;
          }
          
          function checkBackendConfig() {
            const issues = [];
            
            // Check vercel.json
            try {
              const vercelConfig = JSON.parse(fs.readFileSync('backend/vercel.json', 'utf8'));
              if (!vercelConfig.builds || !vercelConfig.routes) {
                issues.push('Invalid or incomplete vercel.json configuration');
              }
            } catch (error) {
              issues.push('Could not read or parse vercel.json');
            }
            
            // Check package.json
            try {
              const packageJson = JSON.parse(fs.readFileSync('backend/package.json', 'utf8'));
              if (!packageJson.scripts || !packageJson.scripts.build) {
                issues.push('Missing build script in package.json');
              }
            } catch (error) {
              issues.push('Could not read or parse package.json');
            }
            
            return issues;
          }
          
          const frontendIssues = checkFrontendConfig();
          const backendIssues = checkBackendConfig();
          
          const report = {
            frontend: frontendIssues,
            backend: backendIssues,
            hasIssues: frontendIssues.length > 0 || backendIssues.length > 0
          };
          
          console.log(JSON.stringify(report));
          EOL
          
          # Run diagnostics
          DIAGNOSTIC_RESULT=$(node diagnose.js)
          echo "result=$DIAGNOSTIC_RESULT" >> $GITHUB_OUTPUT

      - name: Apply fixes
        if: fromJSON(steps.diagnostics.outputs.result).hasIssues
        env:
          GITHUB_TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          # Create fix script
          cat > fix.js << 'EOL'
          const fs = require('fs');
          const path = require('path');
          
          function fixFrontendConfig() {
            // Fix next.config.js
            try {
              let nextConfig = fs.readFileSync('frontend/next.config.js', 'utf8');
              if (!nextConfig.includes('NEXT_PUBLIC_BACKEND_URL')) {
                nextConfig = nextConfig.replace(
                  'module.exports = {',
                  `module.exports = {
                    env: {
                      NEXT_PUBLIC_BACKEND_URL: process.env.NEXT_PUBLIC_BACKEND_URL,
                    },`
                );
                fs.writeFileSync('frontend/next.config.js', nextConfig);
              }
            } catch (error) {
              console.error('Error fixing next.config.js:', error);
            }
            
            // Fix .env
            try {
              fs.appendFileSync('frontend/.env', '\nNEXT_PUBLIC_BACKEND_URL=https://tez-social-production.up.railway.app\n');
            } catch (error) {
              console.error('Error fixing .env:', error);
            }
          }
          
          function fixBackendConfig() {
            // Fix vercel.json
            try {
              const vercelConfig = {
                "version": 2,
                "builds": [
                  {
                    "src": "src/index.ts",
                    "use": "@vercel/node"
                  }
                ],
                "routes": [
                  {
                    "src": "/(.*)",
                    "dest": "src/index.ts"
                  }
                ]
              };
              fs.writeFileSync('backend/vercel.json', JSON.stringify(vercelConfig, null, 2));
            } catch (error) {
              console.error('Error fixing vercel.json:', error);
            }
            
            // Fix package.json
            try {
              const packageJson = JSON.parse(fs.readFileSync('backend/package.json', 'utf8'));
              if (!packageJson.scripts) {
                packageJson.scripts = {};
              }
              packageJson.scripts.build = 'tsc';
              fs.writeFileSync('backend/package.json', JSON.stringify(packageJson, null, 2));
            } catch (error) {
              console.error('Error fixing package.json:', error);
            }
          }
          
          const diagnosticResult = JSON.parse(process.env.DIAGNOSTIC_RESULT);
          
          if (diagnosticResult.frontend.length > 0) {
            fixFrontendConfig();
          }
          
          if (diagnosticResult.backend.length > 0) {
            fixBackendConfig();
          }
          EOL
          
          # Apply fixes
          DIAGNOSTIC_RESULT=${{ steps.diagnostics.outputs.result }} node fix.js
          
          # Commit and push changes if any were made
          if [[ -n $(git status --porcelain) ]]; then
            git config --global user.name "Tez-Social-AutoBot"
            git config --global user.email "autobot@example.com"
            git add .
            git commit -m "fix: automatic deployment fixes
            
            Applied fixes for deployment issues:
            $(echo '${{ steps.diagnostics.outputs.result }}' | jq -r '.frontend + .backend | .[]')"
            git push
          fi

      - name: Trigger redeployment
        if: steps.check-deployment.outputs.deployment_status != 'READY' || fromJSON(steps.diagnostics.outputs.result).hasIssues
        env:
          GITHUB_TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          # Trigger a new deployment by creating an empty commit
          git commit --allow-empty -m "chore: trigger redeployment"
          git push

      - name: Create issue if fixes fail
        if: failure()
        env:
          GITHUB_TOKEN: ${{ steps.auth.outputs.token }}
        run: |
          gh issue create \
            --title "Deployment Issues Detected" \
            --body "The autonomous monitoring system detected deployment issues that could not be automatically fixed.
            
            ## Diagnostic Results
            \`\`\`json
            ${{ steps.diagnostics.outputs.result }}
            \`\`\`
            
            ## Deployment Status
            - Vercel: ${{ steps.check-deployment.outputs.deployment_status }}
            - Railway Health: ${{ steps.check-deployment.outputs.railway_health }}
            
            Please review the workflow logs for more details." 